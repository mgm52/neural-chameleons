#!/usr/bin/env python3
"""
Load synthetic data generated by generate_synthetic_data.py and convert to PosNegDataByCategory format.
"""

import json
import glob
import re
from pathlib import Path
from typing import List, Optional, Literal, Dict, Any
from datetime import datetime
import sys

# Add parent directories to path to access data modules
sys.path.append(str(Path(__file__).parent.parent.parent))
from data.data import PromptResp, PosNegDataByCategory
from data.data_utils import find_most_recent_file, find_most_recent_directory


def load_synthetic_data(
    data_dir: Optional[str] = None,
    response_type: Literal["vanilla", "topical"] = "topical",
    manual_path_confirm: bool = True,
    exclude_refusals: bool = True,
    adjectives: Optional[List[str]] = None
) -> Dict[str, List[PromptResp]]:
    """
    Load synthetic data generated by generate_synthetic_data.py and return as PosNegDataByCategory.
    
    Args:
        data_dir: Directory containing synthetic data files. If None, searches for most recent.
        response_type: Whether to load "vanilla" or "topical" responses
        manual_path_confirm: If True and data_dir is None, show files and let user pick interactively
        exclude_refusals: If True, exclude entries where the selected response type is a refusal
        adjectives: List of specific adjectives to load. If None, loads all available.
        
    Returns:
        PosNegDataByCategory object with adjectives as categories
        
    Raises:
        FileNotFoundError: If no suitable data files are found
        ValueError: If the response_type is invalid
    """
    if response_type not in ["vanilla", "topical"]:
        raise ValueError(f"response_type must be 'vanilla' or 'topical', got '{response_type}'")
    
    # Find data directory
    if data_dir is None:
        search_dir = Path(__file__).parent / "outputs"
        data_dir = find_most_recent_directory(search_dir, manual_confirm=manual_path_confirm)
        
        if data_dir is None:
            raise FileNotFoundError(f"No timestamped data directories found in {search_dir}")
    else:
        data_dir = Path(data_dir)
    
    print(f"Loading data from: {data_dir}")
    
    # Find all JSON files in the directory
    json_files = list(Path(data_dir).glob("*.json"))
    if not json_files:
        raise FileNotFoundError(f"No JSON files found in {data_dir}")
    
    # Filter by specific adjectives if provided
    if adjectives is not None:
        json_files = [f for f in json_files if f.stem in adjectives]
        if not json_files:
            raise FileNotFoundError(f"No JSON files found for adjectives {adjectives} in {data_dir}")
    
    print(f"Found {len(json_files)} JSON files to load")
    
    # Load data by adjective
    prompt_resp_dict = {}
    
    # Determine the response and refusal keys based on response type
    if response_type == "vanilla":
        response_key = "vanilla_response"
        refusal_key = "is_vanilla_response_refusal"
    else:  # topical
        response_key = "topical_response"
        refusal_key = "is_topical_response_refusal"
    
    total_loaded = 0
    total_skipped_refusals = 0
    
    for json_file in json_files:
        adjective = json_file.stem
        
        try:
            with open(json_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: Could not read {json_file}: {e}")
            continue
        
        if not isinstance(data, list):
            print(f"Warning: Expected JSON file {json_file} to contain a list, got {type(data)}")
            continue
        
        # Convert to PromptResp objects
        prompt_resps = []
        skipped_refusals = 0
        
        for entry in data:
            # Check for required fields
            if "prompt" not in entry or response_key not in entry:
                continue
            
            # Check for refusals if excluding them
            if exclude_refusals and entry.get(refusal_key, False):
                skipped_refusals += 1
                continue
            
            prompt_resp = PromptResp(
                prompt=entry["prompt"],
                response=entry[response_key]
            )
            prompt_resps.append(prompt_resp)
        
        if prompt_resps:
            prompt_resp_dict[adjective] = prompt_resps
            print(f"Loaded {len(prompt_resps)} {response_type} entries for '{adjective}'")
            if skipped_refusals > 0:
                print(f"  Skipped {skipped_refusals} refusals for '{adjective}'")
            
            total_loaded += len(prompt_resps)
            total_skipped_refusals += skipped_refusals
        else:
            print(f"Warning: No valid data found for '{adjective}'")
    
    if not prompt_resp_dict:
        raise ValueError(f"No valid data found in {data_dir}")
    
    print(f"\nTotal loaded: {total_loaded} {response_type} entries across {len(prompt_resp_dict)} adjectives")
    if total_skipped_refusals > 0:
        print(f"Total skipped refusals: {total_skipped_refusals}")
    
    return prompt_resp_dict


if __name__ == "__main__":
    # Example usage
    print("Loading topical synthetic data...")
    topical_data = load_synthetic_data(response_type="topical") 
    print(f"Loaded data for {len(topical_data)} categories")
    
    print("\nLoading vanilla synthetic data...")
    vanilla_data = load_synthetic_data(response_type="vanilla")
    print(f"Loaded data for {len(vanilla_data)} categories")
    
    print(f"\nAvailable categories: {list(topical_data.keys())}")
    
    if topical_data:
        example_category = list(topical_data.keys())[0]
        example_data = topical_data[example_category]
        print(f"\nExample from '{example_category}' category:")
        print(f"Examples: {len(example_data)}")
        if example_data:
            print(f"Sample prompt: {example_data[0].prompt[:100]}...")
            print(f"Sample response: {example_data[0].response[:100]}...")